#+TITLE: LET LISP
#+AUTHOR: E.M. From <vertlaforet@protonmail.com>

Welcome fellow lambda enthousiast

Is it fast? Is it the best? LETs find out.


This README is my current thoughts on this project, with unanswered question and rambling. Consume at your own risk.


* Why LET 
L.E.T. = List Eating Trampoline

Since the name closure is already taken and lambda lisp seems a bit greedy.
Also, it _reduces_ LISP (no AST) so there will be no oxidation
Also, the stack is dead. Long live the stack.

* Lisp :)

A LISP (that will at some point in the future be) featuring:
- lazy evaluation
- multithreaded core
- thunk trampoline execution style
- resource id based evaluation (no stack)
- continuation passing
- pure, minus local environment (for brevity) (maybe only as let sugar)
- State and io via delimited continuations (probably promise style)
- Parser and repl under lisp control
- Actual ABI/modules (cause haskell and rust piss me off royally)
- Incidental _and_ explicit memoisation
- Scheme R7-small:ish (unless it violates previously stated goals)

* Stuff todo
** TODO Trampoline
Ring of thunks to perform
Adds executor threads as needed ("add thread" markers in ring)

*** Eval

**** CPS <-> Thunking

The forwards and backwards, and up and down in the AST is mindboggling:

In CPS style
(eval expr env cont)

normally ends with a call (cont <some_result>)
->walking up/left

Converting the AST into thunk does the exact opposite
i.e
return <some_result>

becomes:
generate a thunk, dependant on <some_result>
-> walking down/right the AST

*Thoughts for now*
Read more, stop thinking like traditional eval 
Goal is CPS with dependencies


**** More on CPS 

evaluation is in reality:

preamble -> eval -> continuation

dependency (assuming purity)
preamble <- eval <- continuation

So eval takes dependencies and evalation order and creates a doubly linked list

Each eval thunk produces an id for it's result
Each eval thunk maintains a list of results it depends on

The trampoline goes around the thunk ring and calls thunks where all results are all done

eval collects this information, somehow
a continuation is what to do with the result

I dont need to reify any point
- AST with root at current eval
- Environment

*The continuation literally IS the result id that any thunk in the execution queue will be waiting for!*

#+begin_src
struct thunk {
   id result_id; //Is the continuation, where the thunk is to place the outcome of it's hard work 
   id *dependencies; //Is what the thunk is waiting on to execute
  ...
}
#+end_src

Do I ever need more than a few dependencies?
Do I even need more than one?

#+begin_src
struct thunk {
   id continuation;  
   id dependency; 
  ...
}
  
#+end_src

Allocate a compute thunk
- generate it's id (xor:ing galore) 
- assign result_ = continuation
- pass it's id as the continuation to any eval thunks it queues.
   



** TODO Memory
Ref counting
Caching allocs 

** TODO BIIG Hashtable for references
All results stored in one table
Dependencies tracked for each thunk

** TODO continuation passing eval

** TODO Parser and repl
Parser is integral, (parse <something) is the start of execution

#+begin_src letlisp
(define (parse)
   (display "Penguins!"))
#+end_src

Repl is integral (repl) reads using readline and calls parse

** TODO Compiler
Compile via reference, big hashes needed
Link to ELF libraries

